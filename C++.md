面向对象的三大基本特征：封装、继承、多态<br>
封装：将零散的数据和算法放到一个集合里，方便管理和使用。<br>
继承：子类继承父类的成员属性及函数去使用<br>
多态：父类指针指向子类对象，子类中重写父类的虚函数，达到父类指针指向不同的子类对象，调用相同的函数能实现不同的效果<br>

new(delete)和malloc(free)的共同点： 都来动态申请、释放堆区内存空间。
new(delete)和malloc(free)的区别：
1.new、delete是关键字,也是操作符，需要C++的编译器支持，malloc()、free()是
函数,使用时需要引入对应的头文件。
2.new申请空间不需要指定空间大小，而是指定类型，根据类型会自动计算所需空间大小，malloc()需要指定申请空间大小
3.new返回的是申请类型空间的地址，malloc()返回的地址是void * 型的，需要强转成自己需要的类型
4.new申请类、结构体对象时会调用构造函数，delete会调用析构函数，单独的malloc()和free()不会。

引用与指针的区别
1.引用定义了就要初始化，一旦引用了一块内存空间，就不能引用其余的空间了;而
指针可以不初始化(不建议这样写)，指针的指向可以随意改变。
2.引用，起别名；指针，他有自己的独立空间，指向其他空间。
3.有空的指针，没有空的引用
4.指针可以有多级，引用没有，但是引用可以有多个.
非常量左值引用只能操作左值，无法对右值进行引用，常量左值引用既可以引用左值也可以引用右值。

NULL与nullptr
NULL宏 替换 整型0
nullptr：关键字，空指针类型（需要强转为需要类型）

class类：
访问修饰符：
private：私有的，只能在类内使用，默认修饰符，类外和子类中不可以使用（可以创建公共接口访问）
protected：保护的，类内和子类中能使用，类外不能使用
public：共有的，类内，子类，类外都可以使用

class会有默认的无参构造和析构，当然可以重写构造和析构，重写包括无参重写和有参重写（有参重写不适用于析构），且可以存在多个：存在无参构造，有参构造，但无论是哪种，只要发生了重写默认的无参构造将不存在

结构体和类的区别：
1.类的默认的默认访问修饰符是private 结构体的默认访问符是public
2.类的默认的继承方式是private 结构体的默认继承方式是public

对象的种类：
局部对象：在函数内（包括参数）定义的栈区的局部对象，在函数调用完毕或者遇到 } 时生命周期结束
new的对象：在堆区new的对象，直到执行delete操作声明周期结束
全局对象：生命周期开始早，在main函数执行前都出现，直到程序退出才回收（调用析构）
静态全局对象：生命周期与全局对象一样，如果存在多个静态全局对象，谁先被定义则先执行构造函数，回收时则相反，先被定义（调用构造的）的后被回收（调用析构）。
静态全局对象与全局对象区别：后者在所有源文件共享，前者只是作用于所属源文件中，所以在不同源文件里定义了相同名字的两个静态全局对象也不冲突，因为他们俩是不同作用域的。
静态局部对象：定义在某个函数函数中的对象，并不是在程序创建就被初始化，而是第一次执行该函数定义对象时被初始化，以后在调用该函数不创建新的对象，此对象只会存在一份，如果该函数一直没有执行，那么该静态局部对象与不会创建出来。在程序结束时调用析构销毁。
静态全局对象与静态局部对象的异同：都是在程序结束时调用析构回收，不同的是静态全局对象创建的要早，静态局部对象创建的晚，不过因为其都是在程序结束时回收，所以我们可以在函数外使用静态局部变量

类成员：
类成员属性：属于对象，在定义对象才会真正存在，多个对象会存在多份成员属性，彼此独立，互不干扰。
成员方法：成员方法：属于类，只有一份，在编译期就存在了，与是否存在对象无关。
类成员与普通函数的区别：
1.作用域不同，类成员函数标识了所属的类，必须通过对象调用（虽然可以是空指针对象，但必须得有，因为存在this指针）。
2.在类中非静态成员函数包括构造析构会存在着一个默认的隐藏的参数（this 指 针），它是编译器默认加上的，在所有参数之前，类型为当前类的指针 即： 类 * const this。

this指针的作用：指向了调用该函数的对象(即将对象的地址传给this指针，是连接
成员的属性或方法 和 函数的桥梁。

静态成员属性及方法：
空类定义一个对象，所占空间为1，对象是一个具体的概念，在内存中真实的存在空间，1一个字节占位作用，标识当前对象真实存在于内存，如果类中存在非静态成员，那这个成员可以替换占位的作用，不需要占位的一个字节了。

静态成员属性：不属于对象，属于类的，只有一份 多个对象之间共享这一份静态成员，在编译期就存在了。
在类外定义且初始化，格式：类型 类名::静态成员属性=初值。
可以直接调用（不需要对象调用，属于类），格式：类名::静态成员属性；有对象的时候，也可以通过对象去调用。而非静态成员不可以直接调用。

静态成员函数：不属于对象，属于类的，只有一份，在编译期就存在。
静态成员函数与普通成员函数的区别：
1.静态成员函数没有this指针，静态成员函数只能使用静态成员，普通成员函数既可以使用非静态成员，又可以使用静态成员。
2.静态函数的调用可以直接调用，格式：类名::静态成员方法。但是普通函数不能直接调用，需要对象进行调用。

类中的常量及常函数
类中常量的初始化：一定要在初始化参数列表中。而构造函数的构造函数体代码中的操作严格来讲是赋值，先执行初始化列表，在执行构造函数体中的代码。（常量要保证定义时就被初始化，所以在定义对象的时候就要初始化，就得利用构造函数的初始化参数列表优先初始化）
构造函数的初始化参数列表：用于给类中成员进行初始化(真正的初始化)。
格式：构造函数参数列表:成员属性(初始化值) 初始化多个成员属性用逗号隔开。
注：初始化参数列表 初始化成员的顺序与成员属性在类中声明的顺序有关，和写在初始化参数列表中顺序无关
常函数：返回类型 函数名()const {}，而不是const 返回类型 函数名(){}，前者const修饰的是this指针，后者修饰的是返回类型。

格式：返回类型 函数名()const {}，而不是const 返回类型 函数名(){}，前者const修饰的是this指针，后者修饰的是返回类型。

常函数与普通成员函数的区别：
在常函数中，不能修改非静态的成员属性（只读操作可以），静态成员不受影响（静态成员调用不需要this指针），不能调用非静态的成员函数（可以调用其他常函数），静态成员不受影响。原因是因为常函数的this指针是（const CTest * const this），而非静态函数的this指针是(CTest * const this)，常函数调用非静态函数就是
一个安全级别降低的操作。

常量对象：常量对象：使用const 修饰的对象（如 const CTest tst;） 不能调用普通的成员函数，只能调用常函数。但定义一个普通的对象既可以调用普通成员函数，也可以调用常函数，这里面涉及到了 this指针的安全级别升级还是降级的操作。
CTest const this = &const CTest，这是一个安全级别降级的非法的操作，而普通的对象调用常函数 const CTest const this = &CTest 这是一个安全级别升级的合法操作。

友元函数：
友元函数是一个不属于类成员的函数，但它可以直接访问该类的私有成员。友元函数可以是常规的独立函数，也可以是其他类的成员，实际上，整个类都可以声明为另一个类的友元。
通过关键字friend放置在函数的原型之前，即可将函数声明为友元。

类之间的横向关系：
1.组合（复合）：组合是一个类中包含另一个类对象。举例：人与手，人与头之间的关系，人需要包含头和手，头、手是人的一部分且不能脱离人独立存在。
2.依赖：举例：人要完成编程这件事情，那么需要用到电脑，电脑作为一个工具，其他的时候不需要，电脑也不可能作为人的属性而存在(非组合关系)，人必须依赖电脑才能完成编程这件事情。
3.关联：举例：人和朋友的关系，人要完成玩游戏这个功能，没有朋友可以自己玩游戏，如果交到了朋友就可以和朋友一起玩游戏。
4.聚合：多个被聚合的对象聚集起来形成一个大的整体，聚合的目的是为了统一进行管理同类型的对象，有生命周期约束关系，聚合是一种弱所属关系，被聚合的对象还可以再被别的对象关联，所以被聚合对象是可以共享的。

类之间的纵向关系：继承
父类（基类）与子类（派生类）的关系：
把一些功能相似的类，类中的公共的成员单独抽离出来，放到一个类中，这个类就是父类。

子类继承父类，相当于将父类的成员包含到自己的类里，所以定义子类对象所占用的空间大小除了子类自身的成员还包括父类的成员。成员在内存空间分布为：先父类成员后子类成员，而每个类中的成员分布与在类中定义的顺序一致。
注：如果父类和子类具有同名的成员，那么默认使用的是子类的成员，如果想使用父
类的成员，可以通过 父类名::成员名 的格式进行调用。

继承得优点：多个子类在增加公共方法时，只需要在父类添加一份即可，提高了代码的复用性，扩展性。

三种继承方式：
继承方式与访问修饰符一样，都是三种
继承方式：描述了父类的成员在子类中所能使用的范围，即访问控制。继承方式和访
问修饰符共同决定了父类成员的访问权限。
private(私有继承):
父类：              子类：
private             不可访问
protected           private
public              private
protected()
